-- This script was generated by the Schema Diff utility in pgAdmin 4
-- For the circular dependencies, the order in which Schema Diff writes the objects is not very sophisticated
-- and may require manual changes to the script to ensure changes are applied in the correct order.
-- Please report an issue for any failure with the reproduction steps.

CREATE TABLE IF NOT EXISTS public.tags
(
    id uuid NOT NULL DEFAULT uuid_generate_v4(),
    label character varying COLLATE pg_catalog."default" NOT NULL,
    created_at timestamp with time zone DEFAULT now(),
    updated_at timestamp with time zone DEFAULT now(),
    CONSTRAINT tags_pkey PRIMARY KEY (id),
    CONSTRAINT tags_label_key UNIQUE (label)
)

TABLESPACE pg_default;

ALTER TABLE IF EXISTS public.tags
    OWNER to postgres;

ALTER TABLE IF EXISTS public.tags
    ENABLE ROW LEVEL SECURITY;

GRANT ALL ON TABLE public.tags TO anon;

GRANT ALL ON TABLE public.tags TO authenticated;

GRANT ALL ON TABLE public.tags TO postgres;

GRANT ALL ON TABLE public.tags TO service_role;

COMMENT ON TABLE public.tags
    IS 'Provides a means for categorizing Objectives';
CREATE POLICY "tags - authenticated users can read"
    ON public.tags
    AS PERMISSIVE
    FOR SELECT
    TO public
    USING ((auth.role() = 'authenticated'::text));

CREATE TRIGGER handle_updated_at
    BEFORE UPDATE 
    ON public.tags
    FOR EACH ROW
    EXECUTE FUNCTION extensions.moddatetime('updated_at');

CREATE TABLE IF NOT EXISTS public.games_objectives_assoc
(
    game_id uuid NOT NULL,
    objective_id uuid NOT NULL,
    CONSTRAINT game_objective_assoc_pkey PRIMARY KEY (game_id, objective_id),
    CONSTRAINT game_objective_assoc_game_id_fkey FOREIGN KEY (game_id)
        REFERENCES public.games (id) MATCH SIMPLE
        ON UPDATE NO ACTION
        ON DELETE NO ACTION,
    CONSTRAINT game_objective_assoc_objective_id_fkey FOREIGN KEY (objective_id)
        REFERENCES public.objectives (id) MATCH SIMPLE
        ON UPDATE NO ACTION
        ON DELETE NO ACTION
)

TABLESPACE pg_default;

ALTER TABLE IF EXISTS public.games_objectives_assoc
    OWNER to postgres;

ALTER TABLE IF EXISTS public.games_objectives_assoc
    ENABLE ROW LEVEL SECURITY;

GRANT ALL ON TABLE public.games_objectives_assoc TO anon;

GRANT ALL ON TABLE public.games_objectives_assoc TO authenticated;

GRANT ALL ON TABLE public.games_objectives_assoc TO postgres;

GRANT ALL ON TABLE public.games_objectives_assoc TO service_role;

COMMENT ON TABLE public.games_objectives_assoc
    IS 'Associates games to objectives';

CREATE TABLE IF NOT EXISTS public.tags_objectives_assoc
(
    tag_id uuid NOT NULL,
    objective_id uuid NOT NULL,
    CONSTRAINT tags_objectives_assoc_pkey PRIMARY KEY (tag_id, objective_id),
    CONSTRAINT tags_objectives_assoc_objective_id_fkey FOREIGN KEY (objective_id)
        REFERENCES public.objectives (id) MATCH SIMPLE
        ON UPDATE NO ACTION
        ON DELETE NO ACTION,
    CONSTRAINT tags_objectives_assoc_tag_id_fkey FOREIGN KEY (tag_id)
        REFERENCES public.tags (id) MATCH SIMPLE
        ON UPDATE NO ACTION
        ON DELETE NO ACTION
)

TABLESPACE pg_default;

ALTER TABLE IF EXISTS public.tags_objectives_assoc
    OWNER to postgres;

ALTER TABLE IF EXISTS public.tags_objectives_assoc
    ENABLE ROW LEVEL SECURITY;

GRANT ALL ON TABLE public.tags_objectives_assoc TO anon;

GRANT ALL ON TABLE public.tags_objectives_assoc TO authenticated;

GRANT ALL ON TABLE public.tags_objectives_assoc TO postgres;

GRANT ALL ON TABLE public.tags_objectives_assoc TO service_role;

COMMENT ON TABLE public.tags_objectives_assoc
    IS 'Associates a tag to an objective';
